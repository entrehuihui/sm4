package sm4_test

import (
	"testing"

	"github.com/sammyne/sm4"
)

func TestDecryptOk(t *testing.T) {
	testVector := []struct {
		key    [sm4.KeySize]byte
		src    [sm4.BlockSize]byte
		expect [sm4.BlockSize]byte
	}{
		{
			[sm4.KeySize]byte{
				0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
				0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
			},
			[sm4.BlockSize]byte{
				0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e,
				0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46,
			},
			[sm4.BlockSize]byte{
				0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
				0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
			},
		},
	}

	for i, c := range testVector {
		cc, err := sm4.NewCipher(c.key[:])
		if err != nil {
			t.Fatalf("#%d unexpected error: %v", i, err)
		}

		var got [sm4.BlockSize]byte
		cc.Decrypt(got[:], c.src[:])
		if got != c.expect {
			t.Fatalf("#%d failed: expect %v, got %v", i, c.expect, got)
		}
	}
}

func TestEncryptOk(t *testing.T) {
	testVector := []struct {
		key    [sm4.KeySize]byte
		src    [sm4.BlockSize]byte
		expect [sm4.BlockSize]byte
	}{
		{
			[sm4.KeySize]byte{
				0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
				0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
			},
			[sm4.BlockSize]byte{
				0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
				0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
			},
			[sm4.BlockSize]byte{
				0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e,
				0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46,
			},
		},
	}

	for i, c := range testVector {
		cc, err := sm4.NewCipher(c.key[:])
		if err != nil {
			t.Fatalf("#%d unexpected error: %v", i, err)
		}

		var got [sm4.BlockSize]byte
		cc.Encrypt(got[:], c.src[:])
		if got != c.expect {
			t.Fatalf("#%d failed: expect %v, got %v", i, c.expect, got)
		}
	}
}

func TestEncrypt1_000_000(t *testing.T) {
	testVector := struct {
		key    [sm4.KeySize]byte
		src    [sm4.BlockSize]byte
		expect [sm4.BlockSize]byte
	}{
		[sm4.KeySize]byte{
			0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
			0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
		},
		[sm4.BlockSize]byte{
			0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
			0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
		},
		[sm4.BlockSize]byte{
			0x59, 0x52, 0x98, 0xc7, 0xc6, 0xfd, 0x27, 0x1f,
			0x04, 0x02, 0xf8, 0x04, 0xc3, 0x3d, 0x3f, 0x66,
		},
	}

	cc, err := sm4.NewCipher(testVector.key[:])
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	got := testVector.src
	for i := 0; i < 1_000_000; i++ {
		cc.Encrypt(got[:], got[:])
	}

	if got != testVector.expect {
		t.Fatalf("failed: expect %v, got %v", testVector.expect, got)
	}
}
